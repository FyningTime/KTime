package technology.iatlas.ktime.database.migration

import org.jetbrains.exposed.sql.Database
import java.io.File
import java.sql.Connection
import java.sql.DriverManager
import java.sql.SQLException
import java.text.SimpleDateFormat
import java.util.*
import java.util.regex.Pattern

/**
 * Manages the migration from the old FyningTime SQLite database to the new KTime database.
 */
class DatabaseMigrationManager {
    private lateinit var oldConnection: Connection
    private lateinit var newDatabase: Database
    private val migrationSql = StringBuilder()

    // Data structures to hold migration data
    data class WorkdayData(val id: Int, val date: String, val targetHours: Float, val breakMinutes: Int)
    data class WorktimeData(val id: Int, val type: String, val timestamp: String, val workdayId: Int)
    data class VacationData(val id: Int, val startDate: String, val endDate: String)

    data class MigrationPreview(
        val workdays: List<WorkdayData>,
        val worktimes: List<WorktimeData>,
        val vacations: List<VacationData>
    )

    /**
     * Connects to the old database and analyzes its schema.
     * @param oldDbPath Path to the old FyningTime database file
     * @return True if connection was successful, false otherwise
     */
    fun connectToOldDatabase(oldDbPath: String): Boolean {
        return try {
            Class.forName("org.sqlite.JDBC")
            oldConnection = DriverManager.getConnection("jdbc:sqlite:$oldDbPath")
            true
        } catch (e: Exception) {
            false
        }
    }

    /**
     * Sets the target database for migration.
     * @param database The KTime database instance
     */
    fun setTargetDatabase(database: Database) {
        newDatabase = database
    }

    /**
     * Analyzes the old database and prepares a preview of the data to be migrated.
     * @return A MigrationPreview object containing the data to be migrated
     */
    fun analyzeDatabase(): MigrationPreview {
        val workdays = mutableListOf<WorkdayData>()
        val worktimes = mutableListOf<WorktimeData>()
        val vacations = mutableListOf<VacationData>()

        try {
            // Extract workday data
            oldConnection.createStatement().use { statement ->
                statement.executeQuery("SELECT id, date, time, breaktime FROM workday").use { resultSet ->
                    while (resultSet.next()) {
                        val id = resultSet.getInt("id")
                        val date = resultSet.getString("date")
                        val timeStr = resultSet.getString("time") ?: "0h0m0s"
                        val breaktimeStr = resultSet.getString("breaktime") ?: "0m"

                        val targetHours = parseTimeToHours(timeStr)
                        val breakMinutes = parseBreakTimeToMinutes(breaktimeStr)

                        workdays.add(WorkdayData(id, date, targetHours, breakMinutes))
                    }
                }
            }

            // Extract worktime data
            oldConnection.createStatement().use { statement ->
                statement.executeQuery("SELECT id, type, time, workday FROM worktime").use { resultSet ->
                    while (resultSet.next()) {
                        val id = resultSet.getInt("id")
                        val type = resultSet.getString("type")
                        val timestamp = resultSet.getString("time")
                        val workdayId = resultSet.getInt("workday")

                        worktimes.add(WorktimeData(id, type, timestamp, workdayId))
                    }
                }
            }

            // Extract vacation data
            oldConnection.createStatement().use { statement ->
                statement.executeQuery("SELECT id, startdate, enddate FROM vacations").use { resultSet ->
                    while (resultSet.next()) {
                        val id = resultSet.getInt("id")
                        val startDate = resultSet.getString("startdate")
                        val endDate = resultSet.getString("enddate")

                        vacations.add(VacationData(id, startDate, endDate))
                    }
                }
            }
        } catch (e: SQLException) {
            // Handle database errors
        }

        return MigrationPreview(workdays, worktimes, vacations)
    }

    /**
     * Generates SQL statements for the migration.
     * @param preview The migration preview data
     * @return SQL statements for the migration
     */
    fun generateMigrationSql(preview: MigrationPreview): String {
        val sql = StringBuilder()

        // Add header
        sql.append("-- Migration SQL generated by KTime\n")
        sql.append("-- Date: ${SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US).format(Date())}\n\n")

        // Migrate workdays to CurrentDays
        sql.append("-- Migrate workdays to CurrentDays\n")
        preview.workdays.forEach { workday ->
            // FIXME targetHours should be calculated by current setting
            sql.append("INSERT INTO CurrentDays (date, is_work_day, target_hours, notes) VALUES ('${workday.date}', 1, ${workday.targetHours}, NULL);\n")
        }
        sql.append("\n")

        // Migrate worktimes to WorkTimes
        sql.append("-- Migrate worktimes to WorkTimes\n")
        val worktimesByWorkday = preview.worktimes.groupBy { it.workdayId }
        worktimesByWorkday.forEach { (workdayId, worktimes) ->
            // Find begin and end times
            val beginTime = worktimes.find { it.type == "Begin" }
            val endTime = worktimes.find { it.type == "End" }

            if (beginTime != null) {
                val startTimeStr = extractTimeFromTimestamp(beginTime.timestamp)
                val endTimeStr = endTime?.let { extractTimeFromTimestamp(it.timestamp) } ?: "00:00"

                // Find corresponding workday to get break duration
                val workday = preview.workdays.find { it.id == workdayId }
                val breakDuration = workday?.breakMinutes ?: 0

                // Get the current_day_id from the date
                sql.append("INSERT INTO WorkTimes (current_day_id, start_time, end_time, break_duration, notes) SELECT id, '$startTimeStr', '$endTimeStr', $breakDuration, NULL FROM CurrentDays WHERE date = '${workday?.date}';\n")
            }
        }
        sql.append("\n")

        // Migrate vacations to Vacations
        sql.append("-- Migrate vacations to Vacations\n")
        preview.vacations.forEach { vacation ->
            // Extract date components
            val startDate = extractDateFromTimestamp(vacation.startDate)
            val endDate = extractDateFromTimestamp(vacation.endDate)

            // Create a CurrentDay entry for the vacation start date if it doesn't exist
            sql.append("INSERT OR IGNORE INTO CurrentDays (date, is_work_day, target_hours, notes) VALUES ('$startDate', 0, 0, 'Vacation');\n")

            // Add vacation entry
            sql.append("INSERT INTO Vacations (current_day_id, end_date, type, notes) SELECT id, '$endDate', 'Vacation', NULL FROM CurrentDays WHERE date = '$startDate';\n")
        }
        sql.append("\n")

        // Commit transaction
        sql.append("COMMIT;\n")

        return sql.toString()
    }

    /**
     * Saves the migration SQL to a file.
     * @param filePath Path to save the SQL file
     * @return True if file was saved successfully, false otherwise
     */
    fun saveMigrationSql(filePath: String): Boolean {
        return try {
            File(filePath).writeText(migrationSql.toString())
            true
        } catch (e: Exception) {
            false
        }
    }

    /**
     * Parses a time string in the format "XhYmZs" to hours as a float.
     * @param timeStr The time string to parse
     * @return The time in hours as a float
     */
    private fun parseTimeToHours(timeStr: String): Float {
        val hoursPattern = Pattern.compile("(\\d+)h")
        val minutesPattern = Pattern.compile("(\\d+)m")
        val secondsPattern = Pattern.compile("(\\d+)s")

        var hours = 0
        var minutes = 0
        var seconds = 0

        val hoursMatcher = hoursPattern.matcher(timeStr)
        if (hoursMatcher.find()) {
            hours = hoursMatcher.group(1).toInt()
        }

        val minutesMatcher = minutesPattern.matcher(timeStr)
        if (minutesMatcher.find()) {
            minutes = minutesMatcher.group(1).toInt()
        }

        val secondsMatcher = secondsPattern.matcher(timeStr)
        if (secondsMatcher.find()) {
            seconds = secondsMatcher.group(1).toInt()
        }

        return hours + (minutes / 60f) + (seconds / 3600f)
    }

    /**
     * Parses a break time string in the format "Xm" to minutes as an integer.
     * @param breakTimeStr The break time string to parse
     * @return The break time in minutes as an integer
     */
    private fun parseBreakTimeToMinutes(breakTimeStr: String): Int {
        val minutesPattern = Pattern.compile("(\\d+)m")
        val minutesMatcher = minutesPattern.matcher(breakTimeStr)

        return if (minutesMatcher.find()) {
            minutesMatcher.group(1).toInt()
        } else {
            0
        }
    }

    /**
     * Extracts the time component from a timestamp string.
     * @param timestamp The timestamp string in format "YYYY-MM-DD HH:MM:SS+TZ"
     * @return The time component in format "HH:MM"
     */
    fun extractTimeFromTimestamp(timestamp: String): String {
        return try {
            val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US)
            val date = dateFormat.parse(timestamp.substringBefore("+"))
            val calendar = Calendar.getInstance()
            calendar.time = date

            val hour = calendar.get(Calendar.HOUR_OF_DAY)
            val minute = calendar.get(Calendar.MINUTE)

            String.format("%02d:%02d", hour, minute)
        } catch (e: Exception) {
            "00:00"
        }
    }

    /**
     * Extracts the date component from a timestamp string.
     * @param timestamp The timestamp string in format "YYYY-MM-DD HH:MM:SS+TZ"
     * @return The date component in format "YYYY-MM-DD"
     */
    fun extractDateFromTimestamp(timestamp: String): String {
        return try {
            val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US)
            val date = dateFormat.parse(timestamp.substringBefore("+"))
            val outputFormat = SimpleDateFormat("yyyy-MM-dd", Locale.US)
            outputFormat.format(date)
        } catch (e: Exception) {
            val today = Date()
            val outputFormat = SimpleDateFormat("yyyy-MM-dd", Locale.US)
            outputFormat.format(today)
        }
    }

    /**
     * Closes the connection to the old database.
     */
    fun closeConnection() {
        if (::oldConnection.isInitialized && !oldConnection.isClosed) {
            oldConnection.close()
        }
    }
}
